from lark import Transformer

# Grammar used to parse the the contents of `condition` and `structure` columns.
# See: https://lark-parser.readthedocs.io/en/latest/index.html#
grammar = r"""
%import common.WS
%ignore WS

start: expression+
?expression: string | function

?string: label
label: ALPHANUM | DQSTRING | SQSTRING

function: function_name "(" arguments ")"
function_name: ALPHANUM
arguments: argument ("," argument)*
?argument: string | field | function | named_arg | regex
field: label "." label
named_arg: label "=" label

?regex: regex_sub | regex_match
regex_match: "/" regex_pattern "/" regex_flags
regex_sub: SUB_BEGIN "/" regex_pattern "/" regex_pattern "/" regex_flags
regex_pattern: REGEX_WITH_FORWARD_SLASH | REGEX_WITHOUT_FORWARD_SLASH
regex_flags: LOWER_ALPHA*

SUB_BEGIN: "s"
ALPHANUM: /[a-zA-Z0-9-_]/+
DQSTRING: "\"" /[^"](\\\")?/* "\""
SQSTRING: "'" /[^'](\\\')?/* "'"
LOWER_ALPHA: /[a-z]/
NO_SLASH: /[^\/]/
REGEX_WITH_FORWARD_SLASH: NO_SLASH* "\\/" NO_SLASH*
REGEX_WITHOUT_FORWARD_SLASH: NO_SLASH+
"""


class TreeToDict(Transformer):
    """Transformer to convert a Tree, generated by the grammar used by CMI-PB to parse the contents
    of `condition` and `structure` columns, into a list of expressions represented as dicts."""

    def _sanity_check(self, token_list, expected_len):
        if len(token_list) != expected_len:
            raise Exception(f"Wrong number of tokens in: {token_list} (expecting {expected_len})")

    def label(self, label):
        self._sanity_check(label, 1)
        label = label[0]
        return {"type": "label", "value": label.value}

    def field(self, field):
        self._sanity_check(field, 2)
        return {"type": "field", "table": field[0]["value"], "column": field[1]["value"]}

    def named_arg(self, named_arg):
        self._sanity_check(named_arg, 2)
        return {"type": "named_arg", "key": named_arg[0]["value"], "value": named_arg[1]["value"]}

    def regex_match(self, regex_match):
        self._sanity_check(regex_match, 2)
        return {"type": "regex", "pattern": regex_match[0], "flags": regex_match[1]}

    def regex_sub(self, regex_sub):
        self._sanity_check(regex_sub, 4)
        return {
            "type": "regex",
            "pattern": regex_sub[1],
            "replace": regex_sub[2],
            "flags": regex_sub[3],
        }

    def regex_pattern(self, regex_pattern):
        self._sanity_check(regex_pattern, 1)
        return regex_pattern[0].value

    def regex_flags(self, flags):
        return [flag.value for flag in flags]

    def arguments(self, arguments):
        return arguments

    def function_name(self, function_name):
        self._sanity_check(function_name, 1)
        return function_name[0].value

    def function(self, function):
        self._sanity_check(function, 2)
        return {"type": "function", "name": function[0], "args": function[1]}

    def start(self, start):
        return start


def reverse_parse(config, parsed_cond):
    """Given a config map and a parsed condition, return the text version of the condition."""
    cond_type = parsed_cond["type"]
    text_cond = None
    if cond_type == "label":
        if config["datatype"].get(parsed_cond["value"]):
            text_cond = config["datatype"][parsed_cond["value"]]["datatype"]
        else:
            text_cond = "'{}'".format(parsed_cond["value"])
    elif cond_type == "field":
        return "{}.{}".format(parsed_cond["table"], parsed_cond["column"])
    elif cond_type == "named_arg":
        text_cond = "{}={}".format(parsed_cond["key"], parsed_cond["value"])
    elif cond_type == "regex":
        pattern = parsed_cond["pattern"]
        flags = "".join(parsed_cond["flags"])
        replace = parsed_cond.get("replace")
        text_cond = f"/{pattern}/{flags}" if not replace else f"s/{pattern}/{replace}/{flags}"
    elif cond_type == "function":
        text_cond = map(lambda arg: reverse_parse(config, arg), parsed_cond["args"])
        text_cond = ", ".join(text_cond)
        text_cond = "{}({})".format(parsed_cond["name"], text_cond)
    else:
        raise Exception(f"Unknown parsed_cond type: {cond_type} for {parsed_cond}")

    return text_cond
